# 만화로 배우는 리눅스 시스템 관리 1권

## 2화 임시로 관리자 권한을 얻고 싶어 (sudo)

기본적으로 접근 권한은 파일 소유자가 아니면 변경불가 하지만 root와 같은 관리자 권한은 파일 접근 권한을 변경할 수 있다. 그만큼 위험도도 높으므로 주의가 필요하다. 우분투와 같이 root 로그인을 막는 OS도 있다.

* `sudo [관리자 권한으로 실행하고싶은 명령어]`

우분투에서 root로 로그인하는 방법

* `sudo -i`
* `sudo su`



## 3화 다양한 문자열을 한 번에 검색하고 싶어 (grep)

* global regular expression print
* 파일 전체에서 정규 표현식과 일치하는 위치를 출력하라

```bash 
grep -r "검색할 문자열" /home/grep

# -r : recursively
# /home/grep : 검색 시작점

grep -r -E "(test|Test) *" /home/grep

# -E : 정규식 사용

grep -r -i -E "test *" /home/grep

# -i : ignore case
```

## 4화 터미널에서도 대화형으로 파일을 편집하고 싶어 (vim)

### 기본 흐름

1. 노멀 모드에서 `i` 를 눌러 편집모드
2. `Esc` 로 노멀 모드
3. `:` `w` `q` 로 저장&종료

### 검색 모드

1. 노멀 모드에서 `/` 를 눌러 검색모드
2. 검색
   1. `/search` 와 같이 검색
   2. `/\v([0-9]+)` 의 문법으로 정규 표현식도 사용 가능
3. `n` 을 눌러 정방향 다음 찾기, `N` 으로 역방향 다음 찾기 가능

### cheatsheet

* [vim cheatsheet](https://vim.rtorr.com/lang/ko)

## 5화 vim에서도 복사 & 붙이기 & 되돌리기를 하고 싶어 (yank)

1. 노멀 모드에서 복사할 위치로 커서 이동
2. `v` 를 눌러 비주얼 모드로 변경
3. 화살표로 복사할 범위 까지 이동
4. `y` 를 눌러 yank (끌어당기다)
5. 붙여넣을 위치로 이동하여 `p` (커서의 다음 위치에 붙여넣기)
   - `2` `p` 와 같이 붙여넣기를 반복할 횟수를 지정할 수 있음
   - `Shift`+ `p` 는 커서의 이전 위치에 붙여넣기



- 되돌리기는 `u`

- 되살리기는 `Ctrl` + `r` 
- 역시 마찬가지로 앞에 되돌리기나 되살리기를 수행할 횟수를 지정할 수 있음
  - `9999` `u` 를 이용하면 9999번 되돌린다는 의미 (= 첫 상태로 돌아가는 방법)



### background & foreground

* 콘솔에서 `Ctrl` + `z` 는 현재 실행중인 애플리케이션을 일시 정지하고 background로 보내는 것
* `fg` 명령으로 되돌아올 수 있음

## 6화 갑작스러운 네트워크 끊김에서 복귀하고 싶어 (가상 터미널)

* vim 같은 콘솔 애플리케이션은 데스크톱 환경(GUI)과 다른 규칙으로 동작한다.
* 데스크톱 환경에서 콘솔 환경을 들여다보기 위해 사용하는 것이 GNOME 단말 (터미널)

### 통신장애가 발생한다면?

* 클라이언트 장비에서 서버에 SSH로 접속 후 vim으로 편집하다가 네트워크 오류로 ssh 연결이 끊기면 실행중이던 vim도 종료됨 (서버입장에서는 로그아웃으로 판단하기 때문)
* 이에 대처하기 위해 서버의 콘솔 환경에서 가상 단말을 실행시킨뒤에 vim을 실행할 경우 클라이언트의 ssh 연결이 끊기더라도 가상 단말이 vim을 잡고 있고 클라이언트의 ssh 연결을 다시 기다려주기 때문에 바로 복구가 가능함
* 클라이언트의 단말 -> 클라이언트의 ssh -> (nework) -> 서버의 tmux -> 서버의 vim

### 사용법

* 기본 사용법

```bash
# ssh 연결 후
tmux
# 하려던 작업을 한다.
# NETWORK 에러로 ssh 연결 끊어짐!
# NETWORK 복구 후 다시 ssh 연결 후
tmux attach
# 하던 작업을 이어서 한다.
```

* tmux 사용중에 의도적으로 나오려면 `Ctrl + B` 입력 후 `d`etach 를 누르면 tmux에서 나올 수 있음
* 탭 기능 사용법

```bash
# tmux 사용중 Ctrl+B 누른 뒤 C (reate) 
# 이러면 새로운 가상 화면으로 연결
# Ctrl+B + P, Ctrl+B + N 로 다음, 이전 화면으로 전환 가능
# Ctrl+B + [하단에 표시된 가상 화면 번호] 로도 전환 가능
```

* 각 가상 화면에서는 `exit` 등으로 종료할 수 있음



### 활용 케이스 & 기타

* 갑작스런 끊김에도 대처할 수 있고 서버 작업을 걸어놓고 개인 PC를 종료하는 식으로도 활용가능
* tmux외에 screen, byobu 도 많이 사용됨

## 7화 다른 화면도 보면서 작업하고 싶어 (화면 분할)

* `Ctrl + B` , `"` : 현재 화면을 가로 분할
* `Ctrl + B` , `%` : 현재 화면을 세로 분할
* `Ctrl + B` , `방향키` : 화면간의 포커스 이동
* `Ctrl + B` , `[` : 스크롤
* `exit` : 현재 포커스된 화면의 분할 해제
* `Ctrl + B` 이후 적절히 리듬으로 누르면 연속으로 실행된다. (좀 늦으면 `Ctrl + B` 부터 다시 눌러야함)
* `Ctrl + B` , `Alt + 방향키` 로 분할된 화면들의 크기를 조정가능

## 8화 최근 실행한 명령어를 호출하고 싶어(명령어 이력)

* 방향키 위, 아래로 명령어 이력 이동

* `~/.bash_history` 에 기록됨

* 쉘에서 `Ctrl + R` 을 누르고 명령어 이력을 검색할 수 있다. 단, 역방향으로만 가능하다.

* ~/.bashrc 에 아래 설정을 추가하고 source 명령어로 적용하면 `Ctrl + S` 로 정방향 검색이 가능해진다. (디폴트는 다른 기능에 매핑되어있으므로 이런 설정이 필요한 것)

  ``` bash
  # ...
  stty stop undef
  ```

## 9화 오래전에 실행한 명령어를 호출하고 싶어(명령어 이력 검색)

* bash_history에 저장될 명령어 개수 조정
* ~/.bashrc
  * HISTSIZE : 메모리에 담을 최대 개수
  * HISTFILESIZE : ~/.bash_history 파일에 담을 최대 개수

```bash
# ...
export HISTSIZE=10000
export HISTFILESIZE=10000
```

* 가상 단말에서 여러 화면을 사용할 경우 생성시점의 .bash_history의 메모리 복사본을 기준으로 히스토리를 써나가므로 작업중에는 각 화면간에 명령어 히스토리가 공유되지 않는다.

* 이를 공유하려면 .bashrc에 아래를 추가한다.
```bash
# .bash_history와 메모리 복사본을 자주 동기화하라는 의미
function share_history {
  history -a
  history -c
  history -r
}
PROMPT_COMMAND='share_history'
shopt -u histappend
```

* SSH를 넘어 명령어를 하나만 실행하기

```bash
ssh user@server /scripts/do_something.sh
```

## 10화 네트워크를 건너서 파일을 복사하고 싶어 (scp)

* scp를 실행하면 scp가 SSH를 호출하고 SSH 통신 경로를 사용해서 파일을 보낸다.
* 서버에도 scp가 설치되어 있어야한다.
* 사용법

```bash
scp ~/file.txt user@192.168.1.1:/tmp/
scp user@192.168.1.1:/tmp/file.txt ~/ 
# 현재 서버를 중계지로 복사원본과 복사대상을 모두 원격지로 지정할 수 있음
scp user@192.168.1.1:/tmp/file.txt user@192.168.1.2:/tmp/file.txt 

# 재귀복사
scp -r ~/ user@192.168.1.1:/tmp/
```

## 11화 시스템 과부하를 파악하고 싶어(top)

* load average
  * 1분당 평균으로 몇 개의 일이 쌓이는지를 나타냄. 시스템의 과부하 여부를 판단할 수 있는 기본적인 지표.
  * 일반적으로 코어수 이하로 유지하는 것을 권장되며 초과할 경우 시스템이 과부하 상태임을 알 수 있음
  * 순서대로 1분간, 5분간, 15분간의 평균값
* CPU 부하를 발생시키는 프로세스 찾기
  * %CPU 는 CPU 사용률
  * TIME+ 는 CPU 시간을 나타냄
  * %CPU와 TIME+가 모두 높으면 의심
* `C` 를 누르면 COMMAND 를 자세히 볼 수 있음.
* 부하를 발생시키는 프로세스는 영향도 파악 후 kill 명령어로 죽인다

```bash
kill 111
# 여러개 죽이기
kill 111 222 333
```

## 12화 시스템 메모리 부족을 파악하고 싶어 (top 표시 전환)

* CPU뿐 아니라 메모리 부족으로도 load average는 높아질 수 있음
* 메모리가 부족하면 스왑이 자주 발생하고 이에 따라 I/O 대기 시간이 점점 길어지고 결국 load average가 증가함
  * 스왑아웃 : 메모리 -> 하드
  * 스왑인 : 하드 -> 메모리
* top의 메모리 사용량과 Swap 사용량의 증가를 보고 메모리 문제를 발생시키는 프로세스를 찾을 수 있음
* 하드디스크 영역까지 가득차게 되면 커널은 OOM Killer (Out of Memory Killer) 기능을 통해 적당히 프로세스를 골라 강제종료시킨다. 물론 ssh도 대상이 될 수 있다.
* 부하를 발생시키는 프로세스는 1회성 프로세스는 kill로 죽이지만 apache, sshd 등의 서비스들은 전용 스크립트를 통해 종료하도록 할 것
* top의 프로세스 정렬순서 변경
  * `Shift + P` : CPU 사용량 순서 (기본)
  * `Shift + M` : 메모리 사용량 순서
  * `Shift + T` : CPU 시간 순서

## 13화 로그 파일에서 필요한 줄만 뽑고 싶어 (파이프라인)

* less : more와 비슷하지만 more가 아래로만 이동가능한데 반해서 방향키, page up/down으로 위아래로 움직일 수 있음
* 디렉토리 대상으로 grep 사용

```bash
# /var/log 에서 재귀적으로 orange를 찾음
grep -r "orange" /var/log/
```

* 파이프라인 : `|` 을 사용하여 어떤 명령어의 실행 결과 출력을 다른 명령어로 넘길 수 있음

```bash
# ex
grep /var/log/syslog | grep "kwon" | less
```

* 압축파일 대상으로도 파이프라인을 적용할 수 있는 명령어들

```bash
# zcat : gzip 을 풀어서 출력
zcat /var/log/syslog.2.gz | grep "kwon" | less
```

* 압축 형식에 따른 파이프라인 명령어들
  * zcat : gzip (.gz, .tgz)
  * xzcat : .xz
  * unzip -p
* tail -f 에도 grep 적용 가능함

```bash
tail -f access.log | grep doSomething.do
```

### 파이프라인의 카테고리별 명령어 정리

1. 파일 내용을 다음 명령어에 출력하는 시작 그룹
   - cat, zcat, xzcat
   - tail -f
2. 중간에서 이전 명령어 출력을 가공하는 중간 그룹
   - grep
   - sort
   - cut : 내용을 자름
   - uniq : 중복 제거
   - sed, awk : 내용을 변경함
3. 이전 명령어 출력을 가공하는 최종 그룹
   - less, more : 스크롤할 수 있게 출력
   - tee : 파일을 저장
   - wc
   - head, tail

