# 실습과 그림으로 배우는 리눅스 구조

* 소스
  * https://github.com/kmin135/linux-in-practice
* 실행환경 : ubunut 16.04
* 필요한 패키지

```bash
sudo apt install binutils build-essential sysstat
```

## chap01 컴퓨터 시스템의 개요

* cpu에는 사용자 모드와 커널 모드가 있음
* 프로세스는 사용자 모드로 동작
  * 프로세스가 디바이스 드라이버 같은 커널이 제공하는 기능을 사용하려 할 때는 **시스템 콜**을 통해 커널에 요청함
* 디바이스 드라이버, 프로세스 관리 시스템, 프로세스 스케줄링, 메모리 관리 시스템등은 커널 모드에서만 동작
  * 커널 모드에서 동작하는 OS의 핵심 부분이 되는 처리를 모아 담당하는 프로그램을 커널이라고 부름



## chap02 사용자 모드로 구현되는 기능

* 시스템 콜 : 커널 모드에서만 가능한 동작을 요청하는 것
* 시스템 콜의 종류
  * 프로세스 생성, 삭제
  * 메모리 확보, 해제
  * 프로세스 간 통신 (IPC)
  * 네트워크
  * 파일시스템 다루기
  * 파일 다루기 (디바이스 접근)
* 사용자 모드에서 시스템 콜을 통하지 않고 직접 CPU를 커널 모드로 변경하는 방법은 없다.



1. 시스템콜 분석
    
    - strace 결과 각각의 줄은 1개의 시스템 콜 호출
    
    ```bash
    # -o : 분석결과를 hello.log에 저장
    # -T : 각 시스템콜의 소요시간 (마이크로초), 대신 -tt를 쓰면 ms단위로 출력
    strace -T -o hello.log ./hello
    ```
    
1. CPU 사용현황 분석
    
    - %user + %nice : 사용자 모드에서 프로세스를 실행하는 시간의 비율
    - %system : 커널 모드의 비율
- %idle : CPU 코어상에 프로세스도, 커널도 움직이고 있지 않음을 나타냄
    
    ```bash
    # 1초 단위로 cpu 코어별로 user, kernel 모드의 실행 비율을 확인할 수 있음. Ctrl-C로 나가면 평균을 출력하고 종료
    # %user, %nice, ... 각 행의 모든 필드의 합은 100
    sar -P ALL 1
    
    # 1초 단위로 2번까지 측정하고 종료
    sar -P ALL 1 2
    ```
    
1. 프로그램이 어떤 라이브러리를 링크하는가?
    ```bash
    # 많은 프로그램들이 glibc를 포함함 (libc라고 나오는 부분)
    ldd /bin/echo
    ldd /usr/bin/python3
    ```

* 고급언어로 아키텍쳐에 종속적인 시스템콜(어셈블리로 된)을 호출하기 어려우므로 OS는 시스템 콜의 wrapper 함수를 제공한다. 대표적으로 표준 C 라이브러리인 glibc가 시스템 콜 wrapper 함수를 포함함.

## chap03 프로세스 관리

* 리눅스에서 프로세스를 생성하는 두 가지 목적
  1. 같은 프로그램의 처리를 여러 개의 프로세스가 나눠서 처리한다. 예를 들면 웹 서버처럼 리퀘스트가 여러 개 들어왔을 때 동시에 처리해야 하는 경우
     - fork(), 내부적으로는 clone 시스템 콜
  2. 전혀 다른 프로그램을 생성한다. 예를 들면 bash로부터 각종 프로그램을 새로 생성하는 경우
     - execve(), 내부적으로 execve 시스템 콜
* bash 에서 echo를 실행하면 먼저 fork() 한 다음 자식 프로세스가 execve() 하는 방식으로 동작한다. 이를 `fork and exec` 방식이라 한다.
* fork 는 자식 프로세스 메모리 영역을 작성하고 거기에 부모 프로세스의 메모리를 복사한다. 그 뒤 fork의 리턴값이 부모(자식의 pid)와 자식(0)에서 다르다는 점을 이용해서 실행 처리를 분기한다.
* 반면 execve 는 현재 프로세스의 메모리를 새로운 프로세스의 데이터를 덮어씌우고 새로운 프로세스의 첫 번째 명령어부터 실행한다. 즉, 프로세스의 수가 증가하는 것이 아니고 기존의 프로세스를 별도의 프로세스로 변경하는 방식으로 수행된다. 

## chap04 프로세스 스케줄러

* P61에는 N개의 프로세스를 지정된 시간동안 실행하여 각 프로세스의 단위 시간당 경과시간과 진행도를 기록하는 프로그램 샘플이 있으니 참고

* 하나의 논리 코어에서 특정 순간에 실행되는 프로세스는 1개뿐이다.

* 시스템에 부하가 걸리면 로드밸런서가 프로세스를 여러 개의 논리 CPU에 나눠실행함. 논리 CPU 상에서 동작하는 프로세스가 바뀌는 것을 `컨텍스트 스위치` 라고 함.

* 특정 논리 CPU에서만 수행하고자 할 때는 `taskset` 명령어 사용

    ```bash
    taskset -c 0 ./onlyUseCore0
    taskset -c 0,1 ./useCore0_1
    
    # taskset은 프로세스의 실행을 특정 논리 CPU로 제한하는 sched_setaffinity() 시스템콜을 호출함
    ```

* CPU의 실행 중 혹은 실행 대기 프로세스의 수 표시

  ```bash
  # sar -q 의 필드중 runq-sz 필드는 실행 중 혹은 실행 대기 프로세스의 수를 표시
  sar -q 1 1
  ```

* 논리 CPU가 여러개이면 여러 개의 CPU를 다루기 위해 로드밸런서 또는 글로벌 스케줄러가 동작

### 프로세스의 상태

* 프로세스 상태 확인

```bash
ps ax
```

* 프로세스의 상태 종류
  * 실행 : 논리 CPU 사용중
  * 실행 대기 : CPU 시간이 할당되기를 기다리는 중
  * 슬립 상태 : 이벤트 발생 대기중, 이벤트 발생까지는 CPU 시간을 사용하지 않음.
    * 정해진 시간의 경과 대기, 키보드 등의 사용자 입력 대기, IO 장치의 읽기/쓰기 종료 대기
  * 좀비 상태 : 프로세스 종료 뒤 부모 프로세스가 종료 상태를 인식할 때까지 대기
* 3번째 필드인 STAT의 첫 문자의 의미
  * R : 실행 상태 혹은 실행 대기 상태
  * S, D : 슬립 상태. 시그널에 따라 실행 상태로 돌아오면 'S', 그렇지 않으면 'D'
    * D는 보통 저장 장치의 접근 대기를 의미함. 금방 다른 상태로 바뀌며 장시간 D에 있다면 스토리지의 I/O 문제, 커널 문제를 의심할 수 있음
  * Z : 좀비 상태
  * R : 무언가를 출력하기 위해 동작중 (예를 들면 이 예제의 `ps ax` 프로세스 자체)



### 프로세스 라이프 사이클

1. 프로세스 생성 : 프로세스 라이프사이클의 시작
2. 실행 상태 : 현재 논리 CPU를 사용하고 있음. 
   - 이벤트를 대기해야하면 (sleep, 사용자 입력, IO 등) `슬립 상태`로
   - 종료 처리를 호출하면 `좀비 상태`로
   - CPU 실행권을 잃으면 `실행 대기 상태` 로
3. 실행 대기 상태 : CPU 시간이 할당되기를 기다리고 있음
   - CPU 실행권을 얻으면 `실행 상태` 로
4. 슬립 상태 : 이벤트 발생을 기다리고 있으며 이벤트 발생까지는 CPU 시간을 사용하지 않음.
   - 이벤트가 발생하면 `실행 대기 상태`로.
5. 좀비 상태 : 프로세스 종료 후 부모 프로세스가 종료 상태를 인식할 때까지 기다리고 있음
6. 프로세스 종료 : 부모 프로세스가 종료 상태를 얻어 올바르게 종료된 상태. 라이프사이클의 끝.



### 스루풋과 레이턴시

* 스루풋 : 단위 시간당 처리된 일의 양
  * %idle이 0인데 프로세스를 늘려봐야 스루풋은 늘지 않는다. 오히려 컨텍스트 스위치 등으로 스루풋이 감소한다.
* 레이턴시 : 각각의 처리가 시작부터 종료까지의 경과된 시간
* 성능 목표를 정할 때는 구체적인 목표치를 설정하고 시스템을 튜닝해야한다.
  * 필요한 스루풋과 레이턴시 정의
  * 목표치의 예 : sar의 %idle 수치, sar -q의 runq-sz필드 (전체 논리 CPU의 실행 중 혹은 실행 대기 프로세스의 수를 표시)

### 경과 시간과 사용 시간

* 경과시간 : 프로세스 시작부터 종료까지의 시간
* 사용시간 : 프로세스가 실제로 논리 CPU를 사용한 시간 (슬립, 실행 대기 상태가 제외된 시간이라고 볼 수 있음)
* time 명령어로 얻을 수 있음

```bash
time ./someProgram

real 0m11.567s
user 0m11.560s
sys 0m0.001s

# real이 경과 시간
# user + sys 가 사용 시간. user는 사용자 모드의 CPU시간, sys는 커널이 시스템콜을 실행한 시간

# real보다 user+sys의 값이 클 수 있다. user+sys는 2개 이상의 논리 CPU를 사용할 경우 각 CPU를 사용한 시간의 합계이기 때문이다.
# 예를들어 2개의 논리CPU에 2개의 프로세스를 돌려 사용자모드100ms 만으로 모든 작업이 끝난다면 real은 100ms지만 user는 200ms가 된다.

# 반면에 sleep 명령어같이 idle 상태에 빠지는 명령어라면 real값과 비교하여 user값이 작아진다.
```

* `ps -eo` 명령어

```bash
ps -eo pid,comm,etime,time

# 순서대로 PID, COMMAND, ELAPSED, TIME
# etime이 경과시간, time이 사용시간이다.
```

* cpu 코어수 얻기

```bash
grep -c processor /proc/cpuinfo
```



### 우선순위 변경

* nice() 시스템콜로 조정
  * -19 ~ 20까지 있음. 낮을수록 우선순위가 높음.
  * 기본값은 0.
  * 우선순위를 내리는 것은 root만 가능하고 (0 미만으로 낮추는 것) 
  * 높이는 것은 아무나 가능하다 (1 이상으로 높이는 것)
* `nice` 명령어

```bash
# 우선순위 5로 실행
nice -n 5 echo hello

# sar로 살펴보면 %user가 아닌 %nice를 사용함을 볼 수 있다.
# %nice 필드는 우선순위를 디폴트 값인 0부터 변경한 프로그램을 실행한 시간의 할당량을 나타낸다. (%user는 우선순위 0인 경우)
sar -P ALL 1 
```

### 고찰

* 특정 순간 논리 CPU1개당 동작되는 프로세스는 1개뿐
* %idle이 0인 상태에서 프로세스 수를 논리 CPU 수보다 많게 해도 스루풋은 오르지 않는다.



## 소감

* 당장 어디에 써먹을 수는 없으나 리눅스의 기본 동작 원리 파악에 도움이 됨. 좀 더 low level로 생각할 수 있도록 해주는 책.
* OS적인 트러블슈팅을 할 때 큰 도움이 될 듯.