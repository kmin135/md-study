# 심플 소프트웨어

* 제목대로 소프트웨어를 다룰 때 모든 면에서 심플해야 성공에 이를 수 있음을 강조한다. 내용이 지나치게 가볍거나 극단적이라고 느껴지는 부분도 많았지만 몇몇 주장은 고개를 끄덕이며 읽었다.
* 한 챕터가 짧기 때문에 가끔씩은 눈에 띄는 목차 위주로 읽어보면 좋을 듯.

## Ch04 두 문장으로 요약한 소프트웨어 설계

1. 구현에 드는 수고보다 유지 보수에 드는 수고를 줄이는게 더 중요하다.
2. 유지 보수에 드는 수고는 시스템의 복잡성에 비례한다.

## Ch07 하위 호환성이 가치를 잃는 시점은 언제인가?

* 하위 호환성 유지가 진보를 막는 지경에 이르면 그 '유물'은 이제 한물 갔으므로 버려야 한다는 걸 기억하자.

## Ch10 미래 예측의 정확성

* 현재 데이터, 현재 소프트웨어 시스템을 기반으로 결정을 내릴 때 올바른 방향으로 향할 가능성이 훨씬 높다.
* 소프트웨어 설계 중 발생하는 실수는 미래에 무언가를 반드시 해야 한다고 (혹은 절대 하지 않을 거라고) 가정한 데서 비롯될 때가 많다.

## Ch11 단순성과 엄격성

* 사용자에게 선택지를 줄 뿐 앞서 나가서 추측을 바탕으로 무언가를 해서는 안 된다.
* 입력은 옳거나 옳지 않거나 둘 중 하나일 뿐 '아마'라고 보는 일은 절대 없어야 한다는 게 중요하다.

## Ch17 디버깅의 기본 철학

* 어떤 소프트웨어적 문제가 생겼을 때 즉시 어떤 답을 생각해내려고 했는가? 이미 추측하기 시작했는가? 둘 다 잘못된 접근법이다. 가장 적절한 반응은 "나는 모른다." 이다.
* 긴급한 상황만 아니라면 사용자에게 버그 리포트 중 명확히 가려내야 할 부분에 대한 질문을 보내고 답변을 받는 일부터 해야 한다. 나는 세부 사항이 파악되지 않는 문제는 아예 들여다보지 않는다.
    * 버그 리포트가 허술하다고 사용자에게 무례하게 대하라는건 아니다. 사용자가 이해하기 쉬운 질문을 던져 정보를 얻는 것도 개발자의 업무다.

#### 디버깅의 4단계

1. 정상 시스템의 작동 방식 기억하기
    * 디버깅하려면 시스템이 정상 작동할 때의 데이터와 현재 데이터를 비교해야한다.
2. 문제의 원인을 아직 모른다는 사실을 인정한다.
    * 디버깅은 본인이 아직 답을 모른다고 자각하는 데에서 시작해야 한다.
    * 추측하지마라. 가끔은 추측이 맞기도 하지만 대체로 추측은 시간 낭비다.
3. 문제를 일으키는 원인이 무엇인지 알아낼 때까지 데이터를 살펴본다.
    * 디버깅을 완료하려면 문제의 원인을 이해할때까지 데이터를 수집해야 한다.
    * 원인도 명확하지 않은 문제를 고치기 위해 추측으로 코드베이스를 망치는것보다는 로그, 코어 덤프 등을 더 얻도록 조정한 신규 릴리즈를 배포하고 필요한 데이터를 수집하는 것이 결과적으로 더 빨리 문제를 해결할 수도 있다.
    * 재현이 어려운 문제는 데이터 수집도 어렵다. 이 경우라면 관련된 코드를 면밀하게 분석해서 문제를 찾아야한다.
4. 증상이 아닌 원인을 고친다.
    * 미봉책으로 버그를 가리는 데 급급하면 버그는 코드베이스에 영원히 남아 모두에게 혼란을 야기한다.
    * 자신이 찾은 해결책이 다시는 문제를 재발시키지 않을 거라고 확신할 수 있어야 진짜 원인을 찾은 것이다.

## Ch18 엔지니어링 생산성을 효과적으로 개선하기

* 자기 눈에만 보이는 문제 말고 사람들이 인지하고 있는 문제를 해결하라.

## Ch21 리팩토링할 때는 기능에 주목하라

* 제품 생산과 신뢰할 수 있는 단순하고 빠른 방식으로 제품을 잘 생산하도록 시스템을 정리하는 일, 두 가지를 다 해야 한다. 정리를 포기하면 제품이 완성되지 않고 생산을 포기하면 리팩토링을 할 이유가 없다.
    * 잔디에 물을 주는 건 좋은 일이다. 하지만 불부터 끄자.

## Ch30 단순성과 보안

* 시스템을 단순하게 설계하는 것만이 보안을 보장하는 유일한 방법이다. 시스템의 각 '입구'를 최대한 단순하게 만들고 꼭 필요하지 않은 '입구'는 절대 추가하지 마라.

## Ch32 테스트 철학

* 두 개 이상의 '컴포넌트'를 한 시스템에서 '조립'한 후에 어떻게 작동하는지 보는 것이 통합 테스트다.
* 개발자의 주의가 흩어지기 시작하는 시간이 대략 2초에서 30초 사이라고 한다. 그러므로 개발자가 코드 작성 중에 사용하는 테스트는 그 정도 시간 안에 완료되어야 한다.
* 필요하다면 '느린'테스트 스위트를 별도로 만드는 것도 좋은 방법이다.
* 테스트의 전반적인 목표는 시스템에 관해 유효한 지식을 얻는 것이다.
    * 우리는 코드 보기, 관련 문서 읽기, 개발자와 대화하기 등 다양한 방법을 통해 시스템의 작동 방법에 관한 확신을 얻는다. 하지만 이러한 확신을 입증하는 게 테스트이므로, 다른 방법들보다 특별히 중요하다고 할 수 있다.

## Ch33 성공의 비밀: 나아지기

* 새로운 버전을 출시할 때마다 나아진다면 소프트웨어 프로젝트를 성공으로 이끌 수 있다.

## Ch34 개떡 같은 부분을 찾는 방법

* 나아지고 싶다면 우선 가장 명백한 큰 문제를 찾아라. 그리고 아무리 큰 수고가 들어도 꼭 해결하라.

## Ch35 '아니요'의 힘

* 소프트웨어 설계자가 쓰는 모든 어휘 중 가장 중요한 말은 "아니요."다.
* 모든 문제에는 언제나 좋은 해결책이 존재한다는 걸 믿고 생각이 날 때까지 꾸준이 찾아봐라. 포기하고 나쁜 아이디어를 받아들이지 마라.

> 내 의견 : SI 같은 갑/을 관계에서는 통하지 않는 얘기다. 더 좋은 대안을 제시했고 심지어 나중에 돌아봤을 때 실제로 그랬지만 당시에는 갑의 결정을 뒤집지 못 했던 경우도 있었다. 특히 "누구의 지시사항이라 무조건 해야한다" 라는 식으로 명령이 내려오면 협의는 커녕 대안 제시 자체가 개발팀의 무능력이나 핑계로 취급받는 경우도 있다.

> 그나마 할 수 있는 것은 갑의 지시사항으로 했을 때의 리스크를 지속적으로 어필하는 정도라고 생각한다.

## Ch37 빠른 프로그래밍의 비결: 생각하지 않기

* 그냥 앉아서 생각만 하지 말고 뭔가 해야 한다. 이해에 도달할 유일한 길은 행동이다.
    * 먼저 코드화할 수 있는 부분이 있으면 그것부터 해보고 점진적으로 발전시켜라.
    * 그런게 아니라면 그림을 그려서 이해도를 높이고 다른 사람에게도 의견을 물어봐라. 

> 내 의견 : 공감이 가는 주장이다. 머릿속으로 생각만해봐야 생각이 뒤죽박죽되고 같은 생각을 반복하다가 시간만 흘러가는 패턴이 많았다. 설계할 때도 중요한 마인드라고 본다. 이렇게 설계해도 될까? 라고 의문가는 점이 있다면 나의 생각을 정리하거나 그려서 다른 사람에게 의견을 물어봐야한다. 그 과정에서 내 생각도 더 정리될 거고 다른 사람으로부터 내가 생각하지 못 했던 아이디어를 얻을 수 있다.

* 개발 단계를 건너띄면서 높은 생산성을 기대하지 마라.
    * 예를 들어 자전거 클래스를 만든다면 바퀴가 필요한 지점까지 자전거 클래스부터 충분히 구현하는 것이다. 그리고 자전거 클래스에서 필요한만큼 바퀴 클래스를 만든다. 다시 자전거 클래스로 돌아와서 다른 클래스가 필요한 지점까지 작업을 이어간다. 앞서 이야기했듯이 문제에서 고민없이 풀 수 있는 부분을 찾아서 그 부분부터 해결하라.

## Ch40 사용자는 문제를 알려주고 개발자는 해결책을 만든다

* 사용자는 자신이 경험한 문제를 제대로 말해줄 수 있고, 개발자는 그 문제를 해결할 방법을 올바르게 정할 수 있다.

## Ch43 훌륭한 소프트웨어

* 훌륭한 프로그램은

1. 사용자의 명령을 정확하게 따른다.
    * 시킨 대로 정확히 동작하지 않을 때는 사용자에게 알려야한다.
2. 사용자가 예상한 대로 작동한다.
    * 1번과 충돌할 때는 언제나 사용자가 시킨대로 하라. '사용자가 시킨 대로 하라'라는 규칙을 어겨도 좋을 때는 규칙 위반을 사용자가 예상할거라고 확신할 때뿐이다.
3. 사용자의 의도 전달을 막지 않는다.
    * 사용자의 의도를 프로그램에 최대한 쉽게 전달할 수 있게 하라.
    * "사용자가 멍청하다." 라는 말은 절대해서는 안 된다. "사용자가 쉽게 사용할 정도로 단순하게 만들 방법을 아직 못 찾았다." 라고 해야 한다.

* 코드를 단순하게 만드는 것보다 탁월하게 만드는 게 더 중요하다. 이 둘은 상충되지 않는다.
    * 프로그램을 훌륭하게 만들기 위해 프로그램 내부에 복잡성을 약간 더해야 한다면 그래도 된다.
    * 단, UI를 복잡하게 만들면 프로그램을 훌륭하게 만들지 못 한다.
    * 소프트웨어 설계 원칙을 어기는 일은 그래야만 훌륭한 프로그램이 완성된다고 확신할때만 허용된다.
